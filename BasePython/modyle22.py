# Факториал числа без цикла
#
# def factorial(num):
#     if num == 1:
#         return 1
#     else:
#         return num * factorial(num - 1)
#
# num_fact = factorial(5)
# print(num_fact)
# ----------------------------------------------------------------------------------------------------------------------
# Есть словарь который является структурой сайта.
# Нужно найти значение искомого ключа.
#
# Пример 1:
# Искомый ключ: h2
# Значение: Здесь будет мой заголовок
# Пример 2:
# Искомый ключ: abc
# Такого ключа в структуре сайта нет.
#
# site = {
#     'html': {
#         'head': {
#             'title': 'Мой сайт'
#         },
#         'body': {
#             'h2': 'Здесь будет мой заголовок',
#             'div': 'Тут, наверное, какой-то блок',
#             'p': 'А вот здесь новый абзац'
#         }
#     }
# }
#
# def find_key(struct, key):
#     if key in struct:
#         return struct[key]
#     for sub_struct in struct.values():
#         if isinstance(sub_struct, dict):
#             result = find_key(sub_struct, key)
#             if result:
#                 break
#     else:
#         result = None
#     return result
#
# user_key = input("Искомый ключ: ")
# value = find_key(site, user_key)
# if value:
#     print(value)
# else:
#     print("Такого ключа в структуре сайта нет.")
# ----------------------------------------------------------------------------------------------------------------------
# Пример кода как не изменить исходные переменные в функции
#
# import random
#
# def change_dict(dct):
#     my_dict = dct
#     num = random.randint(1, 100)
#     for i_key, i_value in my_dict.items():
#         if isinstance(i_value, list):
#             i_value.append(num)
#         if isinstance(i_value, dict):
#             i_value[num] = i_key
#         if isinstance(i_value, set):
#             i_value.add(num)
#     return my_dict
#
# nums_list = [1, 2, 3]
# some_dict = {1: 'text', 2: 'another text'}
# uniq_nums = {1, 2, 3}
# common_dict = {1: nums_list, 2: some_dict, 3: uniq_nums, 4: (10, 20, 30)}
#
# change_dict(common_dict)
# print(common_dict)
# print(change_dict(common_dict))
# ---------------------------------------------------------------------------------------------------------------------
#
# Вы пишете небольшое приложение для работы с файлами. Реализуйте функцию, которая может принимать на вход три аргумента:
# вопрос пользователю (на который нужно ответить да или нет),
# сообщение о неправильном вводе и количество попыток.
# Вопрос — обязательный позиционный аргумент, остальные — со значениями по умолчанию.
# При корректном ответе функция может возвращать что угодно — например, число 1 при ответе «да» или 0 при ответе «нет».
#
# В основной программе вызовите функцию минимум три раза:
# только с вопросом, с вопросом и сообщением об ошибке, с вопросом и количеством попыток.
#
# Пример работы программы:
# Вы действительно хотите выйти? что
# Неверный ввод. Пожалуйста, введите 'да' или 'нет'.
# Осталось попыток: 3
# Вы действительно хотите выйти? да
#
# Удалить файл? не знаю
# Так удалить или нет?
# Осталось попыток: 3
# Удалить файл? нет
#
# Записать файл? ага
# Неверный ввод. Пожалуйста, введите 'да' или 'нет'.
# Осталось попыток: 1
# Записать файл? да
#
# def ask_user(question, complaint="Неверный ввод. Пожалуйста, введите 'да' или 'нет'", retries=4):
#     while True:
#         answer = input(question).lower()
#         if answer == 'да':
#             return 1
#         if answer == 'нет':
#             return 0
#         retries -= 1
#         if retries == 0:
#             print("Количество попыток истекло")
#             break
#         print(complaint)
#         print(f"Осталось попыток: {retries}")
#
# ask_user("Вы действительно хотите выйти?")
# ask_user("Удалить файл?", "Так удалить или нет?")
# ask_user("Записать файл?", retries=2)
# ----------------------------------------------------------------------------------------------------------------------
#
# При работе со значениями по умолчанию и изменяемыми типами данных нужно знать и остерегаться ещё одной интересной штуки.
# Напишите функцию с двумя аргументами: первый — число num, позиционный аргумент; второй — список lst, по умолчанию он пустой.
# В теле функции в список добавляется число num и сам список выводится на экран.
# В основной программе вызовите функции три раза только с одним аргументом (числом), например так:
# add_num(5)
# add_num(10)
# add_num(15)
# И посмотрите, что произойдёт.
# После этого сделайте значение lst по умолчанию None и поправьте функцию, чтобы она работала правильно.
#
# def add_num(num, lst=None):
#     lst = []
#     lst.append(num)
#     print(lst)
#
# add_num(5)
# add_num(10)
# add_num(15)
# ----------------------------------------------------------------------------------------------------------------------
#
# def print_tax_document(tax, *args, **kwargs):
#     price_sum = 0
#     for i_price in args:
#         price_sum = price_sum + i_price * tax / 100
#     print(f"Сумма цен с учетом налога: {price_sum}")
#
#     for i_info, i_value in kwargs.items():
#         print(f"{i_info} : {i_value}")
#
# my_tax = int(input("Величина налога: "))
# print_tax_document(my_tax, 1000, 950, 880, 920, 990,
#                    year=1997, doc_type='Report', operation_id=1110034)
# ----------------------------------------------------------------------------------------------------------------------

